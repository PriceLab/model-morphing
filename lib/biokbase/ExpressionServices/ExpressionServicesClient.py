############################################################
#
# Autogenerated by the KBase type compiler -
# any changes made here will be overwritten
#
# Passes on URLError, timeout, and BadStatusLine exceptions.
#     See: 
#     http://docs.python.org/2/library/urllib2.html
#     http://docs.python.org/2/library/httplib.html
#
############################################################

try:
    import json
except ImportError:
    import sys
    sys.path.append('simplejson-2.3.3')
    import simplejson as json
    
import urllib2, httplib, urlparse, random, base64, httplib2
from urllib2 import URLError, HTTPError
from ConfigParser import ConfigParser
import os

_CT = 'content-type'
_AJ = 'application/json'
_URL_SCHEME = frozenset(['http', 'https']) 

# This is bandaid helper function until we get a full
# KBase python auth client released
def _get_token( user_id, password,
                auth_svc="https://nexus.api.globusonline.org/goauth/token?grant_type=client_credentials"):
    h = httplib2.Http( disable_ssl_certificate_validation=True)
    
    auth = base64.encodestring( user_id + ':' + password )
    headers = { 'Authorization' : 'Basic ' + auth }
    
    h.add_credentials(user_id, password)
    h.follow_all_redirects = True
    url = auth_svc
    
    resp, content = h.request(url, 'GET', headers=headers)
    status = int(resp['status'])
    if status>=200 and status<=299:
        tok = json.loads(content)
    elif status == 403: 
        raise Exception( "Authentication failed: Bad user_id/password combination %s:%s" % (user_id, password))
    else:
        raise Exception(str(resp))
        
    return tok['access_token']

# Another bandaid to read in the ~/.authrc file if one is present
def _read_rcfile( file=os.environ['HOME']+"/.authrc"):
    authdata = None
    if os.path.exists( file):
        try:
            with open( file ) as authrc:
                rawdata = json.load( authrc)
                # strip down whatever we read to only what is legit
                authdata = { x : rawdata.get(x) for x in ( 'user_id', 'token',
                                                           'client_secret', 'keyfile',
                                                           'keyfile_passphrase','password')}
        except Exception, e:
            print "Error while reading authrc file %s: %s" % (file, e)
    return authdata

# Another bandaid to read in the ~/.kbase_config file if one is present
def _read_inifile( file=os.environ.get('KB_DEPLOYMENT_CONFIG',os.environ['HOME']+"/.kbase_config")):
    authdata = None
    if os.path.exists( file):
        try:
            config = ConfigParser()
            config.read(file)
            # strip down whatever we read to only what is legit
            authdata = { x : config.get('authentication',x) if config.has_option('authentication',x) else None for x in
                         ( 'user_id', 'token','client_secret', 'keyfile','keyfile_passphrase','password') }
        except Exception, e:
            print "Error while reading INI file %s: %s" % (file, e)
    return authdata

class ServerError(Exception):

    def __init__(self, name, code, message):
        self.name = name
        self.code = code
        self.message = '' if message is None else message

    def __str__(self):
        return self.name + ': ' + str(self.code) + '. ' + self.message
        
class JSONObjectEncoder(json.JSONEncoder):
  
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, frozenset):
            return list(obj)
        return json.JSONEncoder.default(self, obj)

class ExpressionServices:

    def __init__(self, url = None, timeout = 30 * 60, user_id = None, 
                 password = None, token = None, ignore_authrc = False):
        if url is None:
            raise ValueError('A url is required')
        scheme, _, _, _, _, _ = urlparse.urlparse(url)
        if scheme not in _URL_SCHEME:
            raise ValueError(url + " isn't a valid http url")
        self.url = url
        self.timeout = int(timeout)
        self._headers = dict()
        # token overrides user_id and password
        if token is not None:
            self._headers['AUTHORIZATION'] = token
        elif user_id is not None and password is not None:
            self._headers['AUTHORIZATION'] = _get_token( user_id, password)
        elif 'KB_AUTH_TOKEN' in os.environ:
            self._headers['AUTHORIZATION'] = os.environ.get('KB_AUTH_TOKEN')
        elif not ignore_authrc:
            authdata = _read_inifile()
            if authdata is None:
                authdata = _read_rcfile()
            if authdata is not None:
                if authdata.get('token') is not None:
                    self._headers['AUTHORIZATION'] = authdata['token']
                elif authdata.get('user_id') is not None and authdata.get('password') is not None:
                    self._headers['AUTHORIZATION'] = _get_token( authdata['user_id'],authdata['password'] )
        if self.timeout < 1:
            raise ValueError('Timeout value must be at least 1 second')

    def get_expression_samples_data(self, sampleIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_data',
                     'params': [sampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_data_by_samples_and_features(self, sampleIDs, featureIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_data_by_samples_and_features',
                     'params': [sampleIDs, featureIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_data_by_series_ids(self, seriesIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_data_by_series_ids',
                     'params': [seriesIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_series_ids(self, seriesIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_series_ids',
                     'params': [seriesIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_data_by_experimental_unit_ids(self, experimentalUnitIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_data_by_experimental_unit_ids',
                     'params': [experimentalUnitIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_experimental_unit_ids(self, experimentalUnitIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_experimental_unit_ids',
                     'params': [experimentalUnitIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_data_by_experiment_meta_ids(self, experimentMetaIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_data_by_experiment_meta_ids',
                     'params': [experimentMetaIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_experiment_meta_ids(self, experimentMetaIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_experiment_meta_ids',
                     'params': [experimentMetaIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_data_by_strain_ids(self, strainIDs, sampleType):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_data_by_strain_ids',
                     'params': [strainIDs, sampleType],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_strain_ids(self, strainIDs, sampleType):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_strain_ids',
                     'params': [strainIDs, sampleType],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_data_by_genome_ids(self, genomeIDs, sampleType, wildTypeOnly):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_data_by_genome_ids',
                     'params': [genomeIDs, sampleType, wildTypeOnly],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_genome_ids(self, genomeIDs, sampleType, wildTypeOnly):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_genome_ids',
                     'params': [genomeIDs, sampleType, wildTypeOnly],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_data_by_ontology_ids(self, ontologyIDs, AndOr, genomeId, sampleType, wildTypeOnly):

        arg_hash = {'method': 'ExpressionServices.get_expression_samples_data_by_ontology_ids',
                     'params': [ontologyIDs, AndOr, genomeId, sampleType, wildTypeOnly],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_ontology_ids(self, ontologyIDs, AndOr, genomeId, sampleType, wildTypeOnly):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_ontology_ids',
                     'params': [ontologyIDs, AndOr, genomeId, sampleType, wildTypeOnly],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls=JSONObjectEncoder)
        try:
            request = urllib2.Request(self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout=self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_data_by_feature_ids(self, featureIDs, sampleType, wildTypeOnly):

        arg_hash = { 'method': 'ExpressionServices.get_expression_data_by_feature_ids',
                     'params': [featureIDs, sampleType, wildTypeOnly],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def compare_samples(self, numeratorsDataMapping, denominatorsDataMapping):

        arg_hash = { 'method': 'ExpressionServices.compare_samples',
                     'params': [numeratorsDataMapping, denominatorsDataMapping],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def compare_samples_vs_default_controls(self, numeratorSampleIDs):

        arg_hash = { 'method': 'ExpressionServices.compare_samples_vs_default_controls',
                     'params': [numeratorSampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def compare_samples_vs_the_average(self, numeratorSampleIDs, denominatorSampleIDs):

        arg_hash = { 'method': 'ExpressionServices.compare_samples_vs_the_average',
                     'params': [numeratorSampleIDs, denominatorSampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_on_off_calls(self, sampleComparisonMapping, off_threshold, on_threshold):

        arg_hash = { 'method': 'ExpressionServices.get_on_off_calls',
                     'params': [sampleComparisonMapping, off_threshold, on_threshold],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_top_changers(self, sampleComparisonMapping, direction, count):

        arg_hash = { 'method': 'ExpressionServices.get_top_changers',
                     'params': [sampleComparisonMapping, direction, count],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_titles(self, sampleIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_titles',
                     'params': [sampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_descriptions(self, sampleIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_descriptions',
                     'params': [sampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_molecules(self, sampleIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_molecules',
                     'params': [sampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_types(self, sampleIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_types',
                     'params': [sampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_external_source_ids(self, sampleIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_external_source_ids',
                     'params': [sampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_samples_original_log2_medians(self, sampleIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_samples_original_log2_medians',
                     'params': [sampleIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_series_titles(self, seriesIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_series_titles',
                     'params': [seriesIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_series_summaries(self, seriesIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_series_summaries',
                     'params': [seriesIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_series_designs(self, seriesIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_series_designs',
                     'params': [seriesIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_series_external_source_ids(self, seriesIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_series_external_source_ids',
                     'params': [seriesIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_sample_external_source_ids(self, ExternalSourceIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_sample_external_source_ids',
                     'params': [ExternalSourceIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_sample_ids_by_platform_external_source_ids(self, ExternalSourceIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_sample_ids_by_platform_external_source_ids',
                     'params': [ExternalSourceIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_expression_series_ids_by_series_external_source_ids(self, ExternalSourceIDs):

        arg_hash = { 'method': 'ExpressionServices.get_expression_series_ids_by_series_external_source_ids',
                     'params': [ExternalSourceIDs],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_GEO_GSE(self, gse_input_id, metaDataOnly):

        arg_hash = { 'method': 'ExpressionServices.get_GEO_GSE',
                     'params': [gse_input_id, metaDataOnly],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')

    def get_GEO_GSM(self, gsm_input_id, metaDataOnly):

        arg_hash = { 'method': 'ExpressionServices.get_GEO_GSM',
                     'params': [gsm_input_id, metaDataOnly],
                     'version': '1.1',
                     'id': str(random.random())[2:]
                     }

        body = json.dumps(arg_hash, cls = JSONObjectEncoder)
        try:
            request = urllib2.Request( self.url, body, self._headers)
#            ret = urllib2.urlopen(self.url, body, timeout = self.timeout)
            ret = urllib2.urlopen(request, timeout = self.timeout)
        except HTTPError as h:
            if _CT in h.headers and h.headers[_CT] == _AJ:
                b = h.read()
                err = json.loads(b) 
                if 'error' in err:
                    raise ServerError(**err['error'])
                else:            #this should never happen... but if it does 
                    se = ServerError('Unknown', 0, b)
                    se.httpError = h
                    raise se
                    #raise h      #  h.read() will return '' in the calling code.
            else:
                raise h
        if ret.code != httplib.OK:
            raise URLError('Received bad response code from server:' + ret.code)
        resp = json.loads(ret.read())

        if 'result' in resp:
            return resp['result'][0]
        else:
            raise ServerError('Unknown', 0, 'An unknown server error occurred')



